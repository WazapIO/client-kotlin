/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package whatsapi

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import models.APIResponse
import models.WebhookPayload

import com.squareup.moshi.Json

import WhatsAPI.infrastructure.ApiClient
import WhatsAPI.infrastructure.ApiResponse
import WhatsAPI.infrastructure.ClientException
import WhatsAPI.infrastructure.ClientError
import WhatsAPI.infrastructure.ServerException
import WhatsAPI.infrastructure.ServerError
import WhatsAPI.infrastructure.MultiValueMap
import WhatsAPI.infrastructure.PartConfig
import WhatsAPI.infrastructure.RequestConfig
import WhatsAPI.infrastructure.RequestMethod
import WhatsAPI.infrastructure.ResponseType
import WhatsAPI.infrastructure.Success
import WhatsAPI.infrastructure.toMultiValue

class InstanceApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "/api")
        }
    }

    /**
     * Change Webhook url.
     * Changes the webhook url of an instance.
     * @param instanceKey Instance key
     * @param `data` Message data
     * @return APIResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun changeWebhookUrl(instanceKey: kotlin.String, `data`: WebhookPayload) : APIResponse {
        val localVarResponse = changeWebhookUrlWithHttpInfo(instanceKey = instanceKey, `data` = `data`)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as APIResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Change Webhook url.
     * Changes the webhook url of an instance.
     * @param instanceKey Instance key
     * @param `data` Message data
     * @return ApiResponse<APIResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun changeWebhookUrlWithHttpInfo(instanceKey: kotlin.String, `data`: WebhookPayload) : ApiResponse<APIResponse?> {
        val localVariableConfig = changeWebhookUrlRequestConfig(instanceKey = instanceKey, `data` = `data`)

        return request<WebhookPayload, APIResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation changeWebhookUrl
     *
     * @param instanceKey Instance key
     * @param `data` Message data
     * @return RequestConfig
     */
    fun changeWebhookUrlRequestConfig(instanceKey: kotlin.String, `data`: WebhookPayload) : RequestConfig<WebhookPayload> {
        val localVariableBody = `data`
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/instances/{instance_key}/webhook".replace("{"+"instance_key"+"}", encodeURIComponent(instanceKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Creates a new instance key.
     * This endpoint is used to create a new WhatsApp Web instance.
     * @param instanceKey Insert instance key if you want to provide custom key (optional)
     * @return APIResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createInstance(instanceKey: kotlin.String? = null) : APIResponse {
        val localVarResponse = createInstanceWithHttpInfo(instanceKey = instanceKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as APIResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Creates a new instance key.
     * This endpoint is used to create a new WhatsApp Web instance.
     * @param instanceKey Insert instance key if you want to provide custom key (optional)
     * @return ApiResponse<APIResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createInstanceWithHttpInfo(instanceKey: kotlin.String?) : ApiResponse<APIResponse?> {
        val localVariableConfig = createInstanceRequestConfig(instanceKey = instanceKey)

        return request<Unit, APIResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createInstance
     *
     * @param instanceKey Insert instance key if you want to provide custom key (optional)
     * @return RequestConfig
     */
    fun createInstanceRequestConfig(instanceKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (instanceKey != null) {
                    put("instance_key", listOf(instanceKey.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/instances/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Delete Instance.
     * Deletes the instance with the provided key.
     * @param instanceKey Instance key
     * @return APIResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteInstance(instanceKey: kotlin.String) : APIResponse {
        val localVarResponse = deleteInstanceWithHttpInfo(instanceKey = instanceKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as APIResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete Instance.
     * Deletes the instance with the provided key.
     * @param instanceKey Instance key
     * @return ApiResponse<APIResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteInstanceWithHttpInfo(instanceKey: kotlin.String) : ApiResponse<APIResponse?> {
        val localVariableConfig = deleteInstanceRequestConfig(instanceKey = instanceKey)

        return request<Unit, APIResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteInstance
     *
     * @param instanceKey Instance key
     * @return RequestConfig
     */
    fun deleteInstanceRequestConfig(instanceKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/instances/{instance_key}/delete".replace("{"+"instance_key"+"}", encodeURIComponent(instanceKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get contacts.
     * Fetches the list of contacts in the instance.
     * @param instanceKey Instance key
     * @return APIResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getContacts(instanceKey: kotlin.String) : APIResponse {
        val localVarResponse = getContactsWithHttpInfo(instanceKey = instanceKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as APIResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get contacts.
     * Fetches the list of contacts in the instance.
     * @param instanceKey Instance key
     * @return ApiResponse<APIResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getContactsWithHttpInfo(instanceKey: kotlin.String) : ApiResponse<APIResponse?> {
        val localVariableConfig = getContactsRequestConfig(instanceKey = instanceKey)

        return request<Unit, APIResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getContacts
     *
     * @param instanceKey Instance key
     * @return RequestConfig
     */
    fun getContactsRequestConfig(instanceKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/instances/{instance_key}/contacts".replace("{"+"instance_key"+"}", encodeURIComponent(instanceKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get Instance.
     * Returns the instance data of single instance with connection status.
     * @param instanceKey Instance key
     * @return APIResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getInstance(instanceKey: kotlin.String) : APIResponse {
        val localVarResponse = getInstanceWithHttpInfo(instanceKey = instanceKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as APIResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Instance.
     * Returns the instance data of single instance with connection status.
     * @param instanceKey Instance key
     * @return ApiResponse<APIResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getInstanceWithHttpInfo(instanceKey: kotlin.String) : ApiResponse<APIResponse?> {
        val localVariableConfig = getInstanceRequestConfig(instanceKey = instanceKey)

        return request<Unit, APIResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getInstance
     *
     * @param instanceKey Instance key
     * @return RequestConfig
     */
    fun getInstanceRequestConfig(instanceKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/instances/{instance_key}/".replace("{"+"instance_key"+"}", encodeURIComponent(instanceKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get QrCode.
     * Returns the qrcode in the base64 format.
     * @param instanceKey Instance key
     * @return APIResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getQrCode(instanceKey: kotlin.String) : APIResponse {
        val localVarResponse = getQrCodeWithHttpInfo(instanceKey = instanceKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as APIResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get QrCode.
     * Returns the qrcode in the base64 format.
     * @param instanceKey Instance key
     * @return ApiResponse<APIResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getQrCodeWithHttpInfo(instanceKey: kotlin.String) : ApiResponse<APIResponse?> {
        val localVariableConfig = getQrCodeRequestConfig(instanceKey = instanceKey)

        return request<Unit, APIResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getQrCode
     *
     * @param instanceKey Instance key
     * @return RequestConfig
     */
    fun getQrCodeRequestConfig(instanceKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/instances/{instance_key}/qrcode".replace("{"+"instance_key"+"}", encodeURIComponent(instanceKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get all instances.
     * Fetches the list of all Instances with login status.
     * @return APIResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listInstances() : APIResponse {
        val localVarResponse = listInstancesWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as APIResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get all instances.
     * Fetches the list of all Instances with login status.
     * @return ApiResponse<APIResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listInstancesWithHttpInfo() : ApiResponse<APIResponse?> {
        val localVariableConfig = listInstancesRequestConfig()

        return request<Unit, APIResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listInstances
     *
     * @return RequestConfig
     */
    fun listInstancesRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/instances/list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Logout Instance.
     * Logouts of the instance with the provided key.
     * @param instanceKey Instance key
     * @return APIResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun logoutInstance(instanceKey: kotlin.String) : APIResponse {
        val localVarResponse = logoutInstanceWithHttpInfo(instanceKey = instanceKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as APIResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Logout Instance.
     * Logouts of the instance with the provided key.
     * @param instanceKey Instance key
     * @return ApiResponse<APIResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun logoutInstanceWithHttpInfo(instanceKey: kotlin.String) : ApiResponse<APIResponse?> {
        val localVariableConfig = logoutInstanceRequestConfig(instanceKey = instanceKey)

        return request<Unit, APIResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation logoutInstance
     *
     * @param instanceKey Instance key
     * @return RequestConfig
     */
    fun logoutInstanceRequestConfig(instanceKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/instances/{instance_key}/logout".replace("{"+"instance_key"+"}", encodeURIComponent(instanceKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
